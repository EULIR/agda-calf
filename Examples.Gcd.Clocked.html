<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Examples.Gcd.Clocked</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Symbol">{-#</a> <a id="5" class="Keyword">OPTIONS</a> <a id="13" class="Pragma">--prop</a> <a id="20" class="Pragma">--rewriting</a> <a id="32" class="Symbol">#-}</a>

<a id="37" class="Keyword">module</a> <a id="44" href="Examples.Gcd.Clocked.html" class="Module">Examples.Gcd.Clocked</a> <a id="65" class="Keyword">where</a>

<a id="72" class="Keyword">open</a> <a id="77" class="Keyword">import</a> <a id="84" href="Calf.CostMonoid.html" class="Module">Calf.CostMonoid</a>
<a id="100" class="Keyword">import</a> <a id="107" href="Calf.CostMonoids.html" class="Module">Calf.CostMonoids</a> <a id="124" class="Symbol">as</a> <a id="127" class="Module">CM</a>

<a id="131" class="Keyword">open</a> <a id="136" class="Keyword">import</a> <a id="143" href="Calf.html" class="Module">Calf</a> <a id="148" href="Calf.CostMonoids.html#312" class="Function">CM.ℕ-CostMonoid</a>
<a id="164" class="Keyword">open</a> <a id="169" class="Keyword">import</a> <a id="176" href="Calf.Types.Nat.html" class="Module">Calf.Types.Nat</a>
<a id="191" class="Keyword">open</a> <a id="196" class="Keyword">import</a> <a id="203" href="Data.Nat.html" class="Module">Data.Nat</a> <a id="212" class="Keyword">using</a> <a id="218" class="Symbol">(</a><a id="219" href="Data.Nat.Base.html#1544" class="Datatype Operator">_≤_</a><a id="222" class="Symbol">;</a> <a id="224" href="Data.Nat.Base.html#1567" class="InductiveConstructor">z≤n</a><a id="227" class="Symbol">)</a>
<a id="229" class="Keyword">open</a> <a id="234" class="Keyword">import</a> <a id="241" href="Calf.Types.Unit.html" class="Module">Calf.Types.Unit</a>
<a id="257" class="Keyword">open</a> <a id="262" class="Keyword">import</a> <a id="269" href="Calf.Types.Bounded.html" class="Module">Calf.Types.Bounded</a> <a id="288" href="Calf.CostMonoids.html#312" class="Function">CM.ℕ-CostMonoid</a>
<a id="304" class="Keyword">open</a> <a id="309" class="Keyword">import</a> <a id="316" href="Calf.Types.BoundedFunction.html" class="Module">Calf.Types.BoundedFunction</a> <a id="343" href="Calf.CostMonoids.html#312" class="Function">CM.ℕ-CostMonoid</a>

<a id="360" class="Keyword">open</a> <a id="365" class="Keyword">import</a> <a id="372" href="Data.Nat.DivMod.html" class="Module">Data.Nat.DivMod</a>
<a id="388" class="Keyword">open</a> <a id="393" class="Keyword">import</a> <a id="400" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="438" class="Symbol">as</a> <a id="441" class="Module">P</a>
<a id="443" class="Keyword">open</a> <a id="448" class="Keyword">import</a> <a id="455" href="Data.Product.html" class="Module">Data.Product</a>

<a id="469" class="Keyword">open</a> <a id="474" class="Keyword">import</a> <a id="481" href="Examples.Gcd.Euclid.html" class="Module">Examples.Gcd.Euclid</a>

<a id="502" class="Comment">{- Alternative definition of gcd with an explicit clock parameter.
   It is easier to see the computational behavior of the code in this version:
   1) when the clock is nonzero: the algorithm proceeds as normal
   2) clock is zero: algorithm terminates
   Crucially, if the recursor is by-name, then the value of the clock does not
   affect asymptotic behavior of the algorithm.
   Two things one can do in calf:
   1) give a good characterization of the clock in terms of the input by refining the raw recurrence (see Refine.agda)
   2) give a good characterization for of the clock for running the code; this usually
   means finding a clock computation that is simpler to compute
   than the &quot;good&quot; upperbound. For gcd, one can reuse the argument as the clock (see Spec.agda)
-}</a>
<a id="gcd/clocked"></a><a id="1286" href="Examples.Gcd.Clocked.html#1286" class="Function">gcd/clocked</a> <a id="1298" class="Symbol">:</a> <a id="1300" href="Calf.Metalanguage.html#525" class="Function">cmp</a> <a id="1304" class="Symbol">(</a><a id="1305" href="Calf.Metalanguage.html#1832" class="Function">Π</a> <a id="1307" href="Calf.Types.Nat.html#183" class="Function">nat</a> <a id="1311" class="Symbol">λ</a> <a id="1313" href="Examples.Gcd.Clocked.html#1313" class="Bound">_</a> <a id="1315" class="Symbol">→</a> <a id="1317" href="Calf.Metalanguage.html#1832" class="Function">Π</a> <a id="1319" href="Examples.Gcd.Euclid.html#1385" class="Function">gcd/i</a> <a id="1325" class="Symbol">λ</a> <a id="1327" href="Examples.Gcd.Clocked.html#1327" class="Bound">_</a> <a id="1329" class="Symbol">→</a> <a id="1331" href="Calf.Metalanguage.html#330" class="Function">F</a> <a id="1333" href="Calf.Types.Nat.html#183" class="Function">nat</a><a id="1336" class="Symbol">)</a>
<a id="1338" href="Examples.Gcd.Clocked.html#1286" class="Function">gcd/clocked</a> <a id="1350" href="Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a> <a id="1355" class="Symbol">(</a><a id="1356" href="Examples.Gcd.Clocked.html#1356" class="Bound">x</a> <a id="1358" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="1360" href="Examples.Gcd.Clocked.html#1360" class="Bound">y</a> <a id="1362" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="1364" href="Examples.Gcd.Clocked.html#1364" class="Bound">h</a><a id="1365" class="Symbol">)</a> <a id="1367" class="Symbol">=</a> <a id="1369" href="Calf.Metalanguage.html#573" class="Function">ret</a> <a id="1373" href="Examples.Gcd.Clocked.html#1356" class="Bound">x</a>
<a id="1375" href="Examples.Gcd.Clocked.html#1286" class="Function">gcd/clocked</a> <a id="1387" class="Symbol">(</a><a id="1388" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="1392" href="Examples.Gcd.Clocked.html#1392" class="Bound">k</a><a id="1393" class="Symbol">)</a> <a id="1395" class="Symbol">(</a><a id="1396" href="Examples.Gcd.Clocked.html#1396" class="Bound">x</a> <a id="1398" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="1400" class="Number">0</a> <a id="1402" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="1404" href="Examples.Gcd.Clocked.html#1404" class="Bound">h</a><a id="1405" class="Symbol">)</a> <a id="1407" class="Symbol">=</a>  <a id="1410" href="Calf.Metalanguage.html#573" class="Function">ret</a> <a id="1414" class="Symbol">{</a><a id="1415" href="Calf.Types.Nat.html#183" class="Function">nat</a><a id="1418" class="Symbol">}</a> <a id="1420" href="Examples.Gcd.Clocked.html#1396" class="Bound">x</a>
<a id="1422" href="Examples.Gcd.Clocked.html#1286" class="Function">gcd/clocked</a> <a id="1434" class="Symbol">(</a><a id="1435" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="1439" href="Examples.Gcd.Clocked.html#1439" class="Bound">k</a><a id="1440" class="Symbol">)</a> <a id="1442" class="Symbol">(</a><a id="1443" href="Examples.Gcd.Clocked.html#1443" class="Bound">x</a> <a id="1445" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="1447" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="1451" href="Examples.Gcd.Clocked.html#1451" class="Bound">y</a> <a id="1453" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="1455" href="Examples.Gcd.Clocked.html#1455" class="Bound">h</a><a id="1456" class="Symbol">)</a> <a id="1458" class="Symbol">=</a>
  <a id="1462" href="Calf.Metalanguage.html#1111" class="Function">bind</a> <a id="1467" class="Symbol">{</a><a id="1468" href="Examples.Gcd.Euclid.html#798" class="Function">mod-tp</a> <a id="1475" href="Examples.Gcd.Clocked.html#1443" class="Bound">x</a> <a id="1477" class="Symbol">(</a><a id="1478" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="1482" href="Examples.Gcd.Clocked.html#1451" class="Bound">y</a><a id="1483" class="Symbol">)</a> <a id="1485" href="Calf.Types.Unit.html#252" class="InductiveConstructor">triv</a><a id="1489" class="Symbol">}</a> <a id="1491" class="Symbol">(</a><a id="1492" href="Calf.Metalanguage.html#330" class="Function">F</a> <a id="1494" href="Calf.Types.Nat.html#183" class="Function">nat</a><a id="1497" class="Symbol">)</a> <a id="1499" class="Symbol">(</a><a id="1500" href="Examples.Gcd.Euclid.html#949" class="Function">mod</a> <a id="1504" href="Examples.Gcd.Clocked.html#1443" class="Bound">x</a> <a id="1506" class="Symbol">(</a><a id="1507" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="1511" href="Examples.Gcd.Clocked.html#1451" class="Bound">y</a><a id="1512" class="Symbol">)</a> <a id="1514" href="Calf.Types.Unit.html#252" class="InductiveConstructor">triv</a><a id="1518" class="Symbol">)</a>
  <a id="1522" class="Symbol">λ</a> <a id="1524" class="Symbol">{</a> <a id="1526" class="Symbol">(</a><a id="1527" href="Examples.Gcd.Clocked.html#1527" class="Bound">z</a> <a id="1529" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="1531" href="Examples.Gcd.Clocked.html#1531" class="Bound">eqn2</a><a id="1535" class="Symbol">)</a> <a id="1537" class="Symbol">→</a>
  <a id="1541" class="Keyword">let</a> <a id="1545" href="Examples.Gcd.Clocked.html#1545" class="Bound">h2</a> <a id="1548" class="Symbol">=</a> <a id="1550" href="Relation.Binary.PropositionalEquality.Core.html#1803" class="Function">P.subst</a> <a id="1558" class="Symbol">(λ</a> <a id="1561" href="Examples.Gcd.Clocked.html#1561" class="Bound">k</a> <a id="1563" class="Symbol">→</a> <a id="1565" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="1569" href="Examples.Gcd.Clocked.html#1561" class="Bound">k</a> <a id="1571" href="Data.Nat.Base.html#1544" class="Datatype Operator">≤</a> <a id="1573" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="1577" href="Examples.Gcd.Clocked.html#1451" class="Bound">y</a><a id="1578" class="Symbol">)</a> <a id="1580" class="Symbol">(</a><a id="1581" href="Relation.Binary.PropositionalEquality.Core.html#1707" class="Function">P.sym</a> <a id="1587" href="Examples.Gcd.Clocked.html#1531" class="Bound">eqn2</a><a id="1591" class="Symbol">)</a> <a id="1593" class="Symbol">(</a><a id="1594" href="Data.Nat.DivMod.html#3989" class="Function">m%n&lt;n</a> <a id="1600" href="Examples.Gcd.Clocked.html#1443" class="Bound">x</a> <a id="1602" class="Symbol">_)</a> <a id="1605" class="Keyword">in</a>
  <a id="1610" href="Examples.Gcd.Clocked.html#1286" class="Function">gcd/clocked</a> <a id="1622" href="Examples.Gcd.Clocked.html#1439" class="Bound">k</a> <a id="1624" class="Symbol">(</a><a id="1625" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="1629" href="Examples.Gcd.Clocked.html#1451" class="Bound">y</a> <a id="1631" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="1633" href="Examples.Gcd.Clocked.html#1527" class="Bound">z</a> <a id="1635" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="1637" href="Examples.Gcd.Clocked.html#1545" class="Bound">h2</a><a id="1639" class="Symbol">)</a> <a id="1641" class="Symbol">}</a>

<a id="gcd"></a><a id="1644" href="Examples.Gcd.Clocked.html#1644" class="Function">gcd</a> <a id="1648" class="Symbol">:</a> <a id="1650" href="Calf.Metalanguage.html#525" class="Function">cmp</a> <a id="1654" class="Symbol">(</a><a id="1655" href="Calf.Metalanguage.html#1832" class="Function">Π</a> <a id="1657" href="Examples.Gcd.Euclid.html#1385" class="Function">gcd/i</a> <a id="1663" class="Symbol">λ</a> <a id="1665" href="Examples.Gcd.Clocked.html#1665" class="Bound">_</a> <a id="1667" class="Symbol">→</a> <a id="1669" href="Calf.Metalanguage.html#330" class="Function">F</a> <a id="1671" href="Calf.Types.Nat.html#183" class="Function">nat</a><a id="1674" class="Symbol">)</a>
<a id="1676" href="Examples.Gcd.Clocked.html#1644" class="Function">gcd</a> <a id="1680" href="Examples.Gcd.Clocked.html#1680" class="Bound">i</a> <a id="1682" class="Symbol">=</a> <a id="1684" href="Examples.Gcd.Clocked.html#1286" class="Function">gcd/clocked</a> <a id="1696" class="Symbol">(</a><a id="1697" href="Examples.Gcd.Euclid.html#1455" class="Function">gcd/depth</a> <a id="1707" href="Examples.Gcd.Clocked.html#1680" class="Bound">i</a><a id="1708" class="Symbol">)</a> <a id="1710" href="Examples.Gcd.Clocked.html#1680" class="Bound">i</a>

<a id="1713" class="Comment">-- cost of clocked gcd is bounded by for any (not necessarily safe)</a>
<a id="1781" class="Comment">-- instantiation of the clock</a>
<a id="gcd/clocked≤gcd/depth"></a><a id="1811" href="Examples.Gcd.Clocked.html#1811" class="Function">gcd/clocked≤gcd/depth</a> <a id="1833" class="Symbol">:</a> <a id="1835" class="Symbol">∀</a> <a id="1837" href="Examples.Gcd.Clocked.html#1837" class="Bound">k</a> <a id="1839" href="Examples.Gcd.Clocked.html#1839" class="Bound">i</a> <a id="1841" class="Symbol">→</a> <a id="1843" href="Calf.Types.Bounded.html#481" class="Record">IsBounded</a> <a id="1853" href="Calf.Types.Nat.html#183" class="Function">nat</a> <a id="1857" class="Symbol">(</a><a id="1858" href="Examples.Gcd.Clocked.html#1286" class="Function">gcd/clocked</a> <a id="1870" href="Examples.Gcd.Clocked.html#1837" class="Bound">k</a> <a id="1872" href="Examples.Gcd.Clocked.html#1839" class="Bound">i</a><a id="1873" class="Symbol">)</a> <a id="1875" class="Symbol">(</a><a id="1876" href="Examples.Gcd.Euclid.html#1455" class="Function">gcd/depth</a> <a id="1886" href="Examples.Gcd.Clocked.html#1839" class="Bound">i</a><a id="1887" class="Symbol">)</a>
<a id="1889" href="Examples.Gcd.Clocked.html#1811" class="Function">gcd/clocked≤gcd/depth</a> <a id="1911" href="Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a> <a id="1916" href="Examples.Gcd.Clocked.html#1916" class="Bound">i</a> <a id="1918" class="Symbol">=</a> <a id="1920" href="Calf.Types.Bounded.html#807" class="Function">bound/relax</a> <a id="1932" class="Symbol">(λ</a> <a id="1935" href="Examples.Gcd.Clocked.html#1935" class="Bound">_</a> <a id="1937" class="Symbol">→</a> <a id="1939" href="Data.Nat.Base.html#1567" class="InductiveConstructor">z≤n</a><a id="1942" class="Symbol">)</a> <a id="1944" href="Calf.Types.Bounded.html#1247" class="Function">bound/ret</a>
<a id="1954" href="Examples.Gcd.Clocked.html#1811" class="Function">gcd/clocked≤gcd/depth</a> <a id="1976" class="Symbol">(</a><a id="1977" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="1981" href="Examples.Gcd.Clocked.html#1981" class="Bound">k</a><a id="1982" class="Symbol">)</a> <a id="1984" class="Symbol">(</a><a id="1985" href="Examples.Gcd.Clocked.html#1985" class="Bound">x</a> <a id="1987" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="1989" href="Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a> <a id="1994" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="1996" href="Examples.Gcd.Clocked.html#1996" class="Bound">h</a><a id="1997" class="Symbol">)</a> <a id="1999" class="Symbol">=</a> <a id="2001" href="Calf.Types.Bounded.html#1247" class="Function">bound/ret</a>
<a id="2011" href="Examples.Gcd.Clocked.html#1811" class="Function">gcd/clocked≤gcd/depth</a> <a id="2033" class="Symbol">(</a><a id="2034" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="2038" href="Examples.Gcd.Clocked.html#2038" class="Bound">k</a><a id="2039" class="Symbol">)</a> <a id="2041" class="Symbol">(</a><a id="2042" href="Examples.Gcd.Clocked.html#2042" class="Bound">x</a> <a id="2044" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="2046" href="Examples.Gcd.Clocked.html#2046" class="Bound">y</a><a id="2047" class="Symbol">@(</a><a id="2049" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="2053" class="Symbol">_)</a> <a id="2056" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="2058" href="Examples.Gcd.Clocked.html#2058" class="Bound">h</a><a id="2059" class="Symbol">)</a> <a id="2061" class="Keyword">rewrite</a> <a id="2069" href="Examples.Gcd.Euclid.html#2870" class="Function">gcd/depth-unfold-suc</a> <a id="2090" class="Symbol">{</a><a id="2091" class="Argument">h</a> <a id="2093" class="Symbol">=</a> <a id="2095" href="Examples.Gcd.Clocked.html#2058" class="Bound">h</a><a id="2096" class="Symbol">}</a> <a id="2098" class="Symbol">=</a>
  <a id="2102" href="Calf.Types.Bounded.html#1395" class="Function">bound/step</a> <a id="2113" class="Number">1</a> <a id="2115" class="Symbol">_</a> <a id="2117" class="Symbol">(</a><a id="2118" href="Examples.Gcd.Clocked.html#1811" class="Function">gcd/clocked≤gcd/depth</a> <a id="2140" href="Examples.Gcd.Clocked.html#2038" class="Bound">k</a> <a id="2142" class="Symbol">(</a><a id="2143" href="Examples.Gcd.Clocked.html#2046" class="Bound">y</a> <a id="2145" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="2147" href="Examples.Gcd.Clocked.html#2042" class="Bound">x</a> <a id="2149" href="Data.Nat.Base.html#5269" class="Function Operator">%</a> <a id="2151" href="Examples.Gcd.Clocked.html#2046" class="Bound">y</a> <a id="2153" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="2155" href="Data.Nat.DivMod.html#3989" class="Function">m%n&lt;n</a> <a id="2161" href="Examples.Gcd.Clocked.html#2042" class="Bound">x</a> <a id="2163" class="Symbol">_))</a>

<a id="gcd≤gcd/depth"></a><a id="2168" href="Examples.Gcd.Clocked.html#2168" class="Function">gcd≤gcd/depth</a> <a id="2182" class="Symbol">:</a> <a id="2184" class="Symbol">∀</a> <a id="2186" href="Examples.Gcd.Clocked.html#2186" class="Bound">i</a> <a id="2188" class="Symbol">→</a> <a id="2190" href="Calf.Types.Bounded.html#481" class="Record">IsBounded</a> <a id="2200" href="Calf.Types.Nat.html#183" class="Function">nat</a> <a id="2204" class="Symbol">(</a><a id="2205" href="Examples.Gcd.Clocked.html#1644" class="Function">gcd</a> <a id="2209" href="Examples.Gcd.Clocked.html#2186" class="Bound">i</a><a id="2210" class="Symbol">)</a> <a id="2212" class="Symbol">(</a><a id="2213" href="Examples.Gcd.Euclid.html#1455" class="Function">gcd/depth</a> <a id="2223" href="Examples.Gcd.Clocked.html#2186" class="Bound">i</a><a id="2224" class="Symbol">)</a>
<a id="2226" href="Examples.Gcd.Clocked.html#2168" class="Function">gcd≤gcd/depth</a> <a id="2240" href="Examples.Gcd.Clocked.html#2240" class="Bound">i</a> <a id="2242" class="Symbol">=</a> <a id="2244" href="Examples.Gcd.Clocked.html#1811" class="Function">gcd/clocked≤gcd/depth</a> <a id="2266" class="Symbol">(</a><a id="2267" href="Examples.Gcd.Euclid.html#1455" class="Function">gcd/depth</a> <a id="2277" href="Examples.Gcd.Clocked.html#2240" class="Bound">i</a><a id="2278" class="Symbol">)</a> <a id="2280" href="Examples.Gcd.Clocked.html#2240" class="Bound">i</a>

<a id="gcd/bounded"></a><a id="2283" href="Examples.Gcd.Clocked.html#2283" class="Function">gcd/bounded</a> <a id="2295" class="Symbol">:</a> <a id="2297" href="Calf.Metalanguage.html#525" class="Function">cmp</a> <a id="2301" class="Symbol">(</a><a id="2302" href="Calf.Types.BoundedFunction.html#471" class="Function">Ψ</a> <a id="2304" href="Examples.Gcd.Euclid.html#1385" class="Function">gcd/i</a> <a id="2310" class="Symbol">(λ</a> <a id="2313" class="Symbol">{</a> <a id="2315" class="Symbol">_</a> <a id="2317" class="Symbol">→</a> <a id="2319" href="Calf.Types.Nat.html#183" class="Function">nat</a> <a id="2323" class="Symbol">})</a> <a id="2326" href="Examples.Gcd.Euclid.html#1455" class="Function">gcd/depth</a><a id="2335" class="Symbol">)</a>
<a id="2337" href="Examples.Gcd.Clocked.html#2283" class="Function">gcd/bounded</a> <a id="2349" class="Symbol">=</a> <a id="2351" href="Examples.Gcd.Clocked.html#1644" class="Function">gcd</a> <a id="2355" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="2357" href="Examples.Gcd.Clocked.html#2168" class="Function">gcd≤gcd/depth</a>
</pre></body></html>