# **calf**: A Cost-Aware Logical Framework

The **calf** language is a **c**ost-**a**ware **l**ogical **f**ramework for studying quantitative aspects of functional programs.

This repository contains the Agda implementation of **calf**, as well as some case studies of varying complexity.

## HTML Browsing

The source code may be viewed interactively with (semantic) syntax highlighting in the browser using the HTML files in the [`./html`](./html) directory.
These files were generated by running:
```sh
agda --html --html-dir=html src/index.agda
```

You may want to start by opening [`html/index.html`](./html/index.html).

To view a specific module `M`, open `html/M.html` in a web browser.
For example, open [`html/Examples.Sorting.Parallel.html`](./html/Examples.Sorting.Parallel.html) to view module `Examples.Sorting.Parallel`.

## Installation

This implementation of **calf** has been tested using:
- Agda v2.6.2, with `agda-stdlib` v1.7 (preferred)
- Agda v2.6.1.3, with `agda-stdlib` v1.6

Installation instructions may be found in [`INSTALL.md`](./INSTALL.md).

## Language Implementation

### Cost Monoid Parameterization

**calf** is parameterized by a *cost monoid* `(‚ÑÇ, +, zero, ‚â§)`.
The formal definition, `CostMonoid`, is given in [`Calf.CostMonoid`](./src/Calf/CostMonoid.agda).
The definition of a *parallel cost monoid* `(‚ÑÇ, ‚äï, ùüò, ‚äó, ùüô, ‚â§)` is given, as well, as `ParCostMonoid`.

Some common cost monoids and parallel cost monoids are given in [`Calf.CostMonoids`](./src/Calf/CostMonoids.agda); for example, `‚Ñï-CostMonoid` simply tracks sequential cost.
Note that every `ParCostMonoid` induces a `CostMonoid` via the additive substructure `(‚ÑÇ, ‚äï, ùüò, ‚â§)`.

### Core Language

The language itself is implemented via the following files, which are given in a dependency-respecting order.

The following modules are not parameterized:
- [`Calf.Prelude`](./src/Calf/Prelude.agda) contains commonly-used definitions.
- [`Calf.Metalanguage`](./src/Calf/Metalanguage.agda) defines the basic Call-By-Push-Value (CBPV) language, using Agda `postulate`s and rewrite rules.
- [`Calf.PhaseDistinction`](./src/Calf/PhaseDistinction.agda) defines the phase distinction for extension, including the extensional phase `ext`, the open/extensional modality `‚óØ`, and the closed/intensional modality `‚óè`.
- [`Calf.Noninterference`](./src/Calf/Noninterference.agda) gives theorems related to the phase distinction/noninterference.

The following modules are parameterized by a `CostMonoid`:
- [`Calf.Step`](./src/Calf/Step.agda) defines the `step` effect and gives the associated laws via rewrite rules.

The following modules are parameterized by a `ParCostMonoid`:
- [`Calf.ParMetalanguage`](./src/Calf/ParMetalanguage.agda) the parallel pairing operation `_&_`, whose cost is the `ParCostMonoid` product (i.e., `_‚äó_`) of its components, as well as associated laws and lemmas.

### Types

In [`src/Calf/Types`](./src/Calf/Types), we provide commonly-used types.

The following modules are not parameterized:
- [`Calf.Types.Nat`](./src/Calf/Types/Nat.agda), [`Calf.Types.Unit`](./src/Calf/Types/Unit.agda), [`Calf.Types.Bool`](./src/Calf/Types/Bool.agda), [`Calf.Types.Sum`](./src/Calf/Types/Sum.agda), and [`Calf.Types.List`](./src/Calf/Types/List.agda) internalize the associated Agda types via `meta`.
  Notably, this means that their use does *not* incur cost.
- [`Calf.Types.Eq`](./src/Calf/Types/Eq.agda) defines the equality type.

The following modules are parameterized by a `CostMonoid`:
- [`Calf.Types.Bounded`](./src/Calf/Types/Bounded.agda) defines a record `IsBounded A e c` that contains a proof that the cost of `e` (of type `A`) is bounded by `c : ‚ÑÇ`.
  Additionally, it provides lemmas for proving the boundedness of common forms of computations.
- [`Calf.Types.BoundedFunction`](./src/Calf/Types/BoundedFunction.agda) defines cost-bounded functions using `IsBounded`.
- [`Calf.Types.BigO`](./src/Calf/Types/BoundedFunction.agda) gives a definition of "big-O" asymptic bounds as a relaxation of `IsBounded`.

## Examples

We provide a variety of case studies in [`src/Examples`](./src/Examples).

## Sequential

### [`Examples.Id`](./src/Examples/Id.agda)
- `module Easy`
  - Definition of the program `id` which trivially returns its input.
  - Theorem `id/correct` stating the (trivially true) correctness of `id`.
  - Theorem `id‚â§id/cost` stating that the cost of `id n` is bounded by `id/cost n = 0`.
  - Theorem `id/asymptotic : given nat measured-via (Œª n ‚Üí n) , id ‚ààùìû(Œª n ‚Üí 0)` stating that `id` is in `ùìû(0)`.
- `module Hard`
  - Definition of the program `id` which recomputes its input via induction.
  - Theorem `id/correct` stating the correctness of `id`.
  - Theorem `id‚â§id/cost/closed` stating that the cost of `id n` is bounded by `n`.
  - Theorem `id/asymptotic : given nat measured-via (Œª n ‚Üí n) , id ‚ààùìû(Œª n ‚Üí n)` stating that `id` is in `ùìû(n)`, where `n` is the input number.
- A proof that `Easy.id` and `Hard.id` are extensionally equivalent, `easy‚â°hard : ‚óØ (Easy.id ‚â° Hard.id)`.

### [`Examples.Gcd`](./src/Examples/Gcd.agda)
- A **calf** implementation of Euclid's algorithm for gcd.
- [`Examples.Gcd.Euclid`](./src/Examples/Gcd/Euclid.agda)
  - Specification of the cost model via the instrumented operation `mod`.
  - Definition of the type `gcd/i`, which specifies that inputs to Euclid's algorithm should be ordered (first is greater than second).
  - Definition of the program `gcd/depth` that computes the recursion depth of Euclid's algorithm.
- [`Examples.Gcd.Clocked`](./src/Examples/Gcd/Clocked.agda)
  - The clocked version of Euclid's algorithm `gcd/clocked` in which the first parameter is used to justify recursive calls.
  - The actual algorithm `gcd`, obtained by instantiating the clock parameter by `gcd/depth`.
  - The theorem `gcd‚â§gcd/depth` stating that the cost of Euclid's algorithm is bounded by the recursion depth `gcd/depth`.
- [`Examples.Gcd.Spec`](./src/Examples/Gcd/Spec.agda)
  - Theorems `gcd‚â°spec/zero` and `gcd‚â°spec/suc` stating the behavioral correctness of `gcd` in terms of the defining equations of Euclid's algorithm.
- [`Examples.Gcd.Refine`](./src/Examples/Gcd/Refine.agda)
  - Refinement of the bound `gcd/depth` -- the theorem `gcd/depth‚â§gcd/depth/closed` states that the cost of `gcd` is bounded by `suc ‚àò fib‚Åª¬π`.

### [`Examples.Queue`](./src/Examples/Queue.agda)
- A **calf** implementation of [Batched queues](https://en.wikipedia.org/wiki/Queue_(abstract_data_type)#Amortized_queue).
- Specification of the cost model as the number of list iterations via the axiom `list/ind/cons`.
- Upper bounds on the cost of individual enqueue and dequeue operations:
  - The theorem `enq‚â§enq/cost` stating that enqueue has zero cost.
  - The theorem `deq‚â§deq/cost` stating that dequeue has linear cost.
- Amortized analysis of sequences of enqueue and dequeue operations:
  - The theorem `acost‚â§2*|l|` stating that the amortized cost of a sequence of queue operations is at most twice the length of the sequence.

## Parallel

### [`Examples.TreeSum`](./src/Examples/TreeSum.agda)
- Definition of the program `sum` which sums the elements of a tree, incurring unit cost when performing each addition operation.
  At each node, the recursive calls are computed in parallel.
- Theorem `sum‚â§sum/cost/closed` stating that the cost of `sum t` is bounded by `sum/cost/closed t = size t , depth t`.

### [`Examples.Exp2`](./src/Examples/Exp2.agda)
- `module Slow`
  - Definition of the program `exp‚ÇÇ` which computes the exponentation of two by its input by performing two identical recursive calls.
  - Theorem `exp‚ÇÇ/correct` stating the correctness of `exp‚ÇÇ`.
  - Theorem `exp‚ÇÇ‚â§exp‚ÇÇ/cost/closed` stating that the cost of `exp‚ÇÇ n` is bounded by `exp‚ÇÇ/cost/closed n = (pred[2^ n ] , n)`, where `pred[2^ n ] = (2 ^ n) - 1`.
    Since two identical recursive calls are made, the work is exponential, but the span is still linear.
- `module Fast`
  - Definition of the program `exp‚ÇÇ` which computes the exponentation of two by its input via a standard recursive algorithm.
  - Theorem `exp‚ÇÇ/correct` stating the correctness of `exp‚ÇÇ`.
  - Theorem `exp‚ÇÇ‚â§exp‚ÇÇ/cost/closed` stating that the cost of `exp‚ÇÇ n` is bounded by `exp‚ÇÇ/cost/closed n = (n , n)`.
- A proof that `Slow.exp‚ÇÇ` and `Fast.exp‚ÇÇ` are extensionally equivalent, `slow‚â°fast : ‚óØ (Slow.exp‚ÇÇ ‚â° Fast.exp‚ÇÇ)`.

## Hybrid

### [`Examples.Sorting`](./src/Examples/Sorting.agda)
First, we develop a common collection of definitions and theorems used in both sequential and parallel sorting.
- [`Examples.Sorting.Comparable`](./src/Examples/Sorting/Comparable.agda)
  - Record `Comparable` describing the requirements for a type to be comparable, including `h-cost`, a hypothesis that each comparison is bounded by unit cost.
    This serves as the cost model for sorting.
- [`Examples.Sorting.Core`](./src/Examples/Sorting/Core.agda)
  - Predicates for correctness of sorting, based on `Sorted` and the permutation relation `‚Ü≠` from `agda-stdlib`.
    The predicate `IsSort sort` states that `sort` is a correct sorting algorithm.
  - Theorem `IsSort‚áí‚â°`, which states that any two correct sorting algorithms are extensionally equivalent.

#### [`Examples.Sorting.Sequential`](./src/Examples/Sorting/Sequential.agda)
Here, we use cost monoid `‚Ñï-CostMonoid`, tracking the total number of sequential steps incurred.

- [`Examples.Sorting.Sequential.InsertionSort`](./src/Examples/Sorting/Sequential/InsertionSort.agda)
  - Definition of the program `sort` implementing insertion sort.
  - Theorem `sort/correct : IsSort sort` verifying the correctness of `sort`.
  - Theorem `sort‚â§sort/cost/closed` stating that the cost of `sort l` is bounded by `sort/cost/closed l = length l ¬≤`.
  - Theorem `sort/asymptotic : given (list A) measured-via length , sort ‚ààùìû(Œª n ‚Üí n ¬≤)` stating that `sort` is in `ùìû(n ¬≤)`, where `n` is the length of the input list.
- [`Examples.Sorting.Sequential.MergeSort`](./src/Examples/Sorting/Sequential/MergeSort.agda)
    - [`Examples.Sorting.Sequential.MergeSort.Split`](./src/Examples/Sorting/Sequential/MergeSort/Split.agda)
      - Definition of the program `split`, which splits a list in halves.
      - Theorem `split/correct` verifying correctness properties of `split`.
      - Theorem `split‚â§split/cost` stating that the cost of `split l` is bounded by `zero`, since splitting a list into halves requires no comparisons.
    - [`Examples.Sorting.Sequential.MergeSort.Merge`](./src/Examples/Sorting/Sequential/MergeSort/Merge.agda)
      - Definition of the program `merge`, which merges a pair of sorted lists.
      - Theorem `merge/correct` verifying correctness properties of `merge`.
      - Theorem `merge‚â§merge/cost/closed` stating that the cost of `merge (l‚ÇÅ , l‚ÇÇ)` is bounded by `length l‚ÇÅ + length l‚ÇÇ`.
  - Definition of the program `sort` implementing merge sort.
  - Theorem `sort/correct : IsSort sort` verifying the correctness of `sort`.
  - Theorem `sort‚â§sort/cost/closed` stating that the cost of `sort l` is bounded by `sort/cost/closed l = ‚åàlog‚ÇÇ length l ‚åâ * length l`.
  - Theorem `sort/asymptotic : given (list A) measured-via length , sort ‚ààùìû(Œª n ‚Üí n * ‚åàlog‚ÇÇ n ‚åâ)` stating that `sort` is in `ùìû(n * ‚åàlog‚ÇÇ n ‚åâ)`, where `n` is the length of the input list.

Theorem `isort‚â°msort : ‚óØ (ISort.sort ‚â° MSort.sort)` states that `InsertionSort.sort` and `MergeSort.sort` are extensionally equivalent.

#### [`Examples.Sorting.Parallel`](./src/Examples/Sorting/Parallel.agda)
Here, we use *parallel* cost monoid `‚Ñï¬≤-ParCostMonoid`, tracking a pair of natural numbers corresponding to the work (sequential cost) and span (idealized parallel cost), respectively.

- [`Examples.Sorting.Parallel.InsertionSort`](./src/Examples/Sorting/Parallel/InsertionSort.agda)
  - Definition of the program `sort` implementing insertion sort.
  - Theorem `sort/correct : IsSort sort` verifying the correctness of `sort`.
  - Theorem `sort‚â§sort/cost/closed` stating that the cost of `sort l` is bounded by `sort/cost/closed l = (length l ¬≤ , length l ¬≤)`.
  - Theorem `sort/asymptotic : given (list A) measured-via length , sort ‚ààùìû(Œª n ‚Üí n  ¬≤ , n  ¬≤)` stating that `sort` is in `ùìû(n  ¬≤)` work and `ùìû(n  ¬≤)` span, where `n` is the length of the input list.
- [`Examples.Sorting.Parallel.MergeSort`](./src/Examples/Sorting/Parallel/MergeSort.agda)
    - [`Examples.Sorting.Parallel.MergeSort.Split`](./src/Examples/Sorting/Parallel/MergeSort/Split.agda)
      - Definition of the program `split`, which splits a list in halves.
      - Theorem `split/correct` verifying correctness properties of `split`.
      - Theorem `split‚â§split/cost` stating that the cost of `split l` is bounded by `ùüò = (zero , zero)`, since splitting a list into halves requires no comparisons.
    - [`Examples.Sorting.Parallel.MergeSort.Merge`](./src/Examples/Sorting/Parallel/MergeSort/Merge.agda)
      - Definition of the program `merge`, which *sequentially* merges a pair of sorted lists.
      - Theorem `merge/correct` verifying correctness properties of `merge`.
      - Theorem `merge‚â§merge/cost/closed` stating that the cost of `merge (l‚ÇÅ , l‚ÇÇ)` is bounded by `(length l‚ÇÅ + length l‚ÇÇ , length l‚ÇÅ + length l‚ÇÇ)`, since this implementation of `merge` is sequential.
  - Definition of the program `sort` implementing merge sort, where both recursive calls to `sort` are performed in parallel (via the parallel pairing operation `_&_`).
  - Theorem `sort/correct : IsSort sort` verifying the correctness of `sort`.
  - Theorem `sort‚â§sort/cost/closed` stating that the cost of `sort l` is bounded by `sort/cost/closed l = (‚åàlog‚ÇÇ length l ‚åâ * length l , 2 * length l + ‚åàlog‚ÇÇ length l ‚åâ)`.
  - Theorem `sort/asymptotic : given (list A) measured-via length , sort ‚ààùìû(Œª n ‚Üí n * ‚åàlog‚ÇÇ n ‚åâ , n)` stating that `sort` is in `ùìû(n * ‚åàlog‚ÇÇ n ‚åâ)` work and `ùìû(n)` span, where `n` is the length of the input list.
- [`Examples.Sorting.Parallel.MergeSortPar`](./src/Examples/Sorting/Parallel/MergeSortPar.agda)
    - [`Examples.Sorting.Parallel.MergeSortPar.Merge`](./src/Examples/Sorting/Parallel/MergeSortPar/Merge.agda)
      - Definition of the program `merge`, which merges a pair of sorted lists *in parallel* using auxiliary functions `splitMid` and `splitBy`.
      - Theorem `merge/correct` verifying correctness properties of `merge`.
      - Theorem `merge‚â§merge/cost/closed` stating that the cost of `merge (l‚ÇÅ , l‚ÇÇ)` is bounded by `(pred[2^ ‚åàlog‚ÇÇ suc (length l‚ÇÅ) ‚åâ ] * ‚åàlog‚ÇÇ suc (length l‚ÇÇ) ‚åâ , ‚åàlog‚ÇÇ suc (length l‚ÇÅ) ‚åâ * ‚åàlog‚ÇÇ suc (length l‚ÇÇ) ‚åâ)`, where `pred[2^ n ] = (2 ^ n) - 1`.
  - Definition of the program `sort` implementing merge sort, where both recursive calls to `sort` are performed in parallel.
    This is identical to `MergeSort.sort`, but using the parallel merge operation `MergeSortPar.Merge.Merge`.
  - Theorem `sort/correct : IsSort sort` verifying the correctness of `sort`.
  - Theorem `sort‚â§sort/cost/closed` stating that the cost of `sort l` is bounded by `sort/cost/closed l = (‚åàlog‚ÇÇ length l ‚åâ * length l * ‚åàlog‚ÇÇ suc ‚åà length l /2‚åâ ‚åâ , ‚åàlog‚ÇÇ length l ‚åâ * ‚åàlog‚ÇÇ suc ‚åà length l /2‚åâ ‚åâ ¬≤)`.
  - Theorem `sort/asymptotic : given (list A) measured-via length , sort ‚ààùìû(Œª n ‚Üí n * ‚åàlog‚ÇÇ n ‚åâ ¬≤ , ‚åàlog‚ÇÇ n ‚åâ ^ 3)` stating that `sort` is in `ùìû(n * ‚åàlog‚ÇÇ n ‚åâ ¬≤)` work and `ùìû(‚åàlog‚ÇÇ n ‚åâ ^ 3)` span, where `n` is the length of the input list.

Theorem `isort‚â°msort : ‚óØ (ISort.sort ‚â° MSort.sort)` states that `InsertionSort.sort` and `MergeSort.sort` are extensionally equivalent.
Similarly, `msort‚â°psort : ‚óØ (MSort.sort ‚â° PSort.sort)` states that `MergeSort.sort` and `MergeSortPar.sort` are extensionally equivalent.
